{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Bitwise-Operation","result":{"pageContext":{"currentCategory":"Bitwise-Operation","categories":["All","OS","Memory","Paging","TIL","Spring-Security","Spring-Boot","Jwt","Login","Algorithm","DP","2D-Array-DP","Segment-Tree","Divide&Conquer","Blog","Java","BitMasking","BFS","DFS","Implementation","Geometry","Disjoin-Set","Union-Find","Set","Kruskal","Line-Sweeping","Greedy","Bitwise-Operation","Palindrome","Network","TCP","CIA","RSA","JWT","OSI-7계층","UDP","Session","Brute-Force","Combination","Data-Structure","Two-Pointer","Simulation","Math"],"edges":[{"node":{"id":"16cacb14-14bd-5978-80bc-9774c052f0db","excerpt":"SWEA 10762 - 사탕 나누기 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 사탕 나누기  💥 How to Solve?  편의상 동원이를 형이라 하고 그 동생을 동생이라고 칭한다. \n형은 동생보다 많은 사탕을 가지고 싶어하고 동생은 사탕 수를 XOR 연산을 통해서 계산한다. 각 사탕 봉지안의 사탕 수를  이라고 할 때, 동생 기준으로는  이런 식이 나와야 한다. 우선 이 문제의 핵심은 XOR 연산자이다. XOR 연산자의 경우 비트간 서로 다른 경우에만 1이 된다. 즉 위와 같은 연산,  의 결과가 나온다. XOR 연산의 특징 하나를 알면 굉장히 쉽게 해결할 수 있다.\n XOR 연산은  이라면 위와 같은 특징을 이용한다면 굉장히 쉽게 해결할 수 있다.  주어진 모든 수들을 XOR 한 결과를 통해 그 결과가 0이라면\n 동생에게 최소 사탕 봉지 딱 하나만 넘겨주고 나머지는 형이 독식한다해도 동생의 기준으로는 공평한 배분이 된다.  ✨ Python Code  💥 끝!! ✨ …","fields":{"slug":"/swea-10762-사탕나누기/"},"frontmatter":{"categories":"Algorithm Bitwise-Operation","title":"SWEA 10762 - 사탕 나누기 [SWEA 문제 - 비트 연산 활용 문제]","date":"May 16, 2022"}},"next":{"fields":{"slug":"/swea-4699-콩순이의 가장 싼 팰린드롬/"}},"previous":{"fields":{"slug":"/swea-6959-이상한나라의덧셈게임/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}