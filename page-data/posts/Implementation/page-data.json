{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Implementation","result":{"pageContext":{"currentCategory":"Implementation","categories":["All","OS","Memory","Paging","TIL","Spring-Security","Spring-Boot","Jwt","Login","Algorithm","DP","2D-Array-DP","Segment-Tree","Divide&Conquer","Blog","Java","BitMasking","BFS","DFS","Implementation","Geometry","Disjoin-Set","Union-Find","Set","Kruskal","Line-Sweeping","Greedy","Bitwise-Operation","Palindrome","Network","TCP","CIA","RSA","JWT","OSI-7계층","UDP","Session","Brute-Force","Combination","Data-Structure","Two-Pointer","Simulation","Math"],"edges":[{"node":{"id":"61ee2b86-71e1-59ab-8260-b15ab1da9280","excerpt":"SWEA 14362 - 무한 로봇 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 무한 로봇  🔥 주의할 점  k번째로 명령을 수행한 직후의 위치를 라고 할 때, 는 모든 좌표를 의미한다. 로봇이 이동을 마치고 난 후의 점이 아닌 이동 중 마주한 모든 정수 좌표들을 의미한다.  💥 How to Solve?  결과부터 말하자면, 테스트 케이스는 125개, 최대 움직임은 2500회이다. \n내가 구현한 방법은 움직임이 Worst Case인 경우 총 4번을 반복해야하니 10000회 이루어지고, \n모든 TC가 10000회 이루어진다해도 125만회로 제한 시간 3초 이내에 해결할 수 있다고 판단해 단순 구현 방법으로 해결했다.  ‼ Point ‼  우선 용어 몇 가지를 정의하고 시작한다. | ➡ | ⬇ | ⬅ | ⬆ | ➡ | \n움직임 : 로봇이 움직인 방향을 기록한 데이터\n초기 방향 : Right\n시작 방향 : 첫 움직임 방향 - ex) RS 라고 한다면 맨 처음 Right에서 오른…","fields":{"slug":"/swea-14362-무한로봇/"},"frontmatter":{"categories":"Algorithm Implementation Geometry","title":"SWEA 14362 - 무한 로봇 [SWEA 문제 - Implementation, Geometry]","date":"May 20, 2022"}},"next":{"fields":{"slug":"/swea-4111-무선단속카메라/"}},"previous":{"fields":{"slug":"/boj-17471-게리맨더링/"}}},{"node":{"id":"1f918123-0dc3-5aec-a8ab-e505719e5457","excerpt":"BOJ 2140 - 지뢰찾기 Gold Ⅴ  BOJ 2140 - 지뢰찾기  문제 지뢰찾기는 N×N에서 이뤄지는 게임이다. 보드의 곳곳에는 몇 개의 지뢰가 숨겨져 있고, 지뢰가 없는 칸에는 그 칸과 인접(상하좌우 및 대각선)해 있는 8개의 칸들에 몇 개의 지뢰가 숨겨져 있는지에 대한 정보가 주어진다. 게이머는 게임을 진행하면서 보드의 칸을 하나씩 열게 된다. 만약 그 칸에 지뢰가 있다면 게임이 끝나고, 없는 경우에는 그 칸에 적혀있는 숫자, 즉 그 칸과 인접해 있는 8개의 칸들 중 몇 개의 칸에 지뢰가 있는지를 알 수 있게 된다. 이 문제는 보드의 테두리가 모두 열려있고, 그 외는 모두 닫혀있는 상태에서 시작한다. 예를 들어 다음과 같은 경우를 보자. 1 1 1 0 0 2 # # # 1 3 # # # 1 2 # # # 1 1 2 2 1 0 #는 닫혀있는 칸을 나타낸다. 이러한 보드가 주어졌을 때, 닫혀있는 칸들 중 최대 몇 개의 칸에 지뢰가 묻혀있는지 알아내는 프로그램을 작성하시오. …","fields":{"slug":"/boj-2140-지뢰찾기/"},"frontmatter":{"categories":"Algorithm Implementation Greedy","title":"BOJ 2140 - 지뢰찾기 [Implementation, Greedy]","date":"April 24, 2022"}},"next":{"fields":{"slug":"/boj-17947-상남자곽철용/"}},"previous":{"fields":{"slug":"/boj-9015-정사각형/"}}},{"node":{"id":"de485fb0-2363-51cd-ae0f-78a04795dc38","excerpt":"BOJ 23291 - 어항정리 Platinum Ⅴ  BOJ 23291 - 어항정리  💥 Rule  1. 물고기 추가 - add_fish() 가장 적은 수의 물고기가 담긴 모든 어항에 물고기 한 마리씩 추가한다.\n 배열을 순회하면서 min 값을 갖는 인덱스를 모두 저장해둔다.\n 해당 인덱스에 해당하는 어항에 물고기 한 마리씩 추가한다.  ✨ Python Code  2. 어항 쌓기 - stack_bowl() 세로 배열과 가로 배열로 구분해서 관리할 것이다.\n 모든 세로 배열의 끝에서부터의 원소들과 가로 배열의 첫 번째부터의 원소들이 짝을 이뤄 새로운 하나의 세로 배열을 생성하게 된다.\n 세로 배열 하나의 길이가 가로 배열의 길이보다 커질때까지 어항을 쌓을 수 있다. \n이해를 위해 그림을 추가한다.  ✨ Python Code  3. 물고기 조정하기 - balance() 각 어항들의 인접한 어항들간의 차이를 줄이는 과정이다. 인접한 어항들간의 차이를 diff 라 하고, diff를 5로 나…","fields":{"slug":"/boj-23291-어항정리/"},"frontmatter":{"categories":"Algorithm Implementation Simulation","title":"BOJ 23291 - 어항정리 [Implementation, Simulation]","date":"April 15, 2022"}},"next":{"fields":{"slug":"/boj-9320-금고열기/"}},"previous":{"fields":{"slug":"/boj-17947-상남자곽철용/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}