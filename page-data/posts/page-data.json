{"componentChunkName":"component---src-templates-category-template-js","path":"/posts","result":{"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"45871712-2bf3-5269-a0c3-1e508fcc95d7","excerpt":"👩‍💻 OS - Memory Management (2) [Paging] 3️⃣ NonContiguous Memory Allocation - Paging, Segment 앞서 봤던 Contiguous Allocation은 외부 단편화 문제를 해결하기 위한 방법으로 NonContiguous Memory Allocation 방법들이 있습니다. 그 중 Paging과 Segment를 알아보겠습니다. Paging Paging 은 NonContiguous Allocation 방식이다. 고정된 크기로 메모리는 Frame, 프로세스는 Page로 분할하여 관리한다. 한 프로새스는 여러 Page로 나뉘고 main memory에서 필요한 page를 순서 관계없이 Frame에 mapping해준다.  Paging 장점 & 단점 장점 Physical memory를 frame 단위로 분할해 사용하기 때문에 External Fragment 발생할 일이 없다. 할당/해제 가 빠르다 Shared Page를 통해 자원을 쉽…","fields":{"slug":"/os-paging-1/"},"frontmatter":{"categories":"OS Memory Paging TIL","title":"OS - Memory Management (2) [Paging]","date":"January 01, 2023"}},"next":{"fields":{"slug":"/os-memory-management/"}},"previous":null},{"node":{"id":"05b7756f-ea82-5723-909d-d2e30b48b576","excerpt":"👩‍💻 OS - Memory Management (1) Preview  1️⃣ Background - Memory Mapping & Protection, MMU, Virtual Memory, Swapping\n 2️⃣ Contiguous Memory Allocation - Block 3️⃣ NonContiguous Memory Allocation - Paging, Segment  1️⃣ Background 🛡️Memory Mapping & Protection logical 주소를 physical 주소로 mapping 하고 Out Of Memory 관리 [ 메모리 접근 범위 관리 ] ®️ Base Register & Limit Register Base Register : Physical Address(RAM)의 시작 주소\n(Relocation Register) Limit Register : 현 프로그램이 사용할 수 있는 register의 마지막 주소 위 두 Register를 통해 Logical Addess…","fields":{"slug":"/os-memory-management/"},"frontmatter":{"categories":"OS Memory Paging TIL","title":"OS - Memory Management (1)","date":"December 31, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-6/"}},"previous":{"fields":{"slug":"/os-paging-1/"}}},{"node":{"id":"599e092c-bb76-5e6e-b155-0e2a6be490a6","excerpt":"SecurityJwtLogin - 6 [Login & Signup & logout]  Structure 💥 전반적인 구조는 아래 그림과 같이 작성될 예정입니다. - Controller - Service - Mapper 구조   content","fields":{"slug":"/securityjwtlogin-6/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 6 [Login & Signup & logout]","date":"December 06, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-5/"}},"previous":{"fields":{"slug":"/os-memory-management/"}}},{"node":{"id":"2343b1be-c8e6-5f1a-a42c-02b1b6709743","excerpt":"SecurityJwtLogin - 5 [JWT Filter & ExceptionHandler]  Spring Security Filter Spring-Security 는 Filter 기반으로 동작합니다. 큰 그림을 보면 아래 그림과 같습니다.  출처 : gngsn님 블로그 큰 흐름은 위와 같고, 이를 모두 이해하기엔 어려움이 있어 우선 당장 사용하는 기능들에 필요한 부분만 이용하겠습니다. UsernamePasswordAuthenticationFilter 🔥 기본적으로 Authentication(인증)을 담당하는 필터는 AbstractAuthenticationProcessingFilter이다. AbstractAuthenticationProcessingFilter는 추상 클래스로 SecurityFilterChain에 직접 들어갈 수 없습니다. UsernamePasswordAuthenticationFilter는 이를 상속받은 클래스이다. UsernamePasswordAuthenticat…","fields":{"slug":"/securityjwtlogin-5/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 5 [JWT Filter & ExceptionHandler]","date":"December 06, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-4/"}},"previous":{"fields":{"slug":"/securityjwtlogin-6/"}}},{"node":{"id":"5f54c138-b734-53cd-96f8-e6887a1954ae","excerpt":"SecurityJwtLogin - 4 [Token Provider]  Token Provider 토큰을 생성, 토큰으로부터 Authentication 생성, 유효성 검사 등의 작업을 수행할 Token Provider를 작성합니다. 이 때, 인스턴스가 생성되는 시점에 필요한 작업이 있습니다. 일반적으로 생성자가 호출될 때 수행합니다. 이 경우에 어떤 문제가 발생하는지 알아보겠습니다.  InitializingBean VS @PostConstruct 일반적인 생성자 호출 시점에 수행 🌈 SingleTon 으로 관리한다고 가정 new Foo() 를 수행하게 되면 Animal 이 등록되지 않았기 때문에 NULL 이 된다. 또한, Proxy 등의 이유로 Spring Framework에서 여러 번 호출될 수 있는 생성자이기 때문에 animal을 여러 번 출력하게 됩니다. 이를 생성자 주입과 @PostConstruct로 수정한 코드를 살펴보겠습니다. @PostConstruct 생성자 주입을 통해…","fields":{"slug":"/securityjwtlogin-4/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 4 [Token Provider]","date":"December 03, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-3/"}},"previous":{"fields":{"slug":"/securityjwtlogin-5/"}}},{"node":{"id":"d12e8094-4148-53ee-b596-ceefdaf736c9","excerpt":"SecurityJwtLogin - 3 [기본 Model 생성]  VO & DTO  User : 사용자 Entity Token : Token Entity Authority : 권한 정보 JwtResponseDto : 응답 DTO  User 권한의 경우 여러 권한을 가질 수 있으니 위와 같이 Collection으로 관리합니다.  JwtResponse 최초 발급 시 access token, refresh token 모두 발급해주고, 유저 아이디와 권한 정보를 함께 보내줬습니다. 토큰 외의 정보는 어떤 정보를 보내줄 것인가에 따라서 설정하면 됩니다. access token 재발급 시 토큰만 재발급해줬습니다. 🌈 모든 코드는 junhyxxn GitHub에서 확인할 수 있습니다!! VO & DTO User JwtResponse","fields":{"slug":"/securityjwtlogin-3/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 3 [기본 Model 생성]","date":"December 02, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-2/"}},"previous":{"fields":{"slug":"/securityjwtlogin-4/"}}},{"node":{"id":"100ea7c9-c919-5bd2-8ab5-c38344389337","excerpt":"SecurityJwtLogin - 2 [DB 설계]  MySQL DB 설계 ERD  단순한 프로젝트의 경우 User Table에 Authority 를 포함시키는 편이 더 간단합니다. 하지만, 복잡한 프로젝트의 경우 한 user가 여러 autority를 가질 수 있습니다. 예를 든다면, 강사가 존재하고 그 직속으로 조교라는 개념이 존재한다면 강사는 조교의 권한과 강사의 권한을 모두 갖게 됩니다. ⭐ 따라서, 위와 같이 한 유저가 여러 권한을 가질 수 있도록 ERD를 구성했습니다.  일반적으로 사용자별 권한 관리 방식과 그룹별 권한 관리 방식이 존재한다고 합니다. MySQL DB 설계 ERD","fields":{"slug":"/securityjwtlogin-2/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 2 [DB 설계]","date":"December 02, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-1/"}},"previous":{"fields":{"slug":"/securityjwtlogin-3/"}}},{"node":{"id":"b524e060-b47b-559d-8bb2-672a204fe189","excerpt":"SecurityJwtLogin - 1 [초기 프로젝트 설정]  Dependencies and Version  spring boot 의 경우 3.0.0 은 에러가 발생합니다. 따라서 2.7.6을 선택해줍니다. (되도록 SNAPSHOT은 피합니다.)  기본 설정 Dependency 를 추가할 때 설명이 적혀있지만 한 번 가볍게 살펴보겠습니다. Spring Web : Web 관련 Dependency Spring Boot DevTools : LiveReload 기능 제공 Lombok : Annotation 을 통해 Getter, Setter, Constructor 등을 사용가능 하도록 제공 Spring Security : 인증, 인가 등의 보안을 처리하기에 편리하도록 제공하는 Framework MyBatis Framework : Persistence Framework로 DB에 접근할 Connection Pool 등을 담당하고 SQL을 준비할 프레임워크 MySQL Driver : MySQL…","fields":{"slug":"/securityjwtlogin-1/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 1 [프로젝트 설정]","date":"December 01, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-0/"}},"previous":{"fields":{"slug":"/securityjwtlogin-2/"}}},{"node":{"id":"45b7be86-c7ff-58c8-840b-768519a67392","excerpt":"SecurityJwtLogin - 0 [개요 - Spring Security Framework]  Spring Security를 적용한 Jwt 기반 로그인 프로젝트 - 0 프로젝트 시작 전 가볍게 스프링 시큐리티와 JWT 로그인 방식을 알아보고 시작하겠습니다.  🔒 Spring Security Framework  Spring Security는 Spring 기반의 Application의 보안을 담당하는 Framework 이다. 인증(Authentication)과 인가(Authorization)에 대한 처리를 Filter 기반으로 처리를 해주며 많은 Filter가 제공되어 많은 보안 관련 옵션들을 개발자가 하나씩 작성하지 않고 쉽게 처리할 수 있는 장점이 있습니다.  Authentication & Authorization  1️⃣ Authentication - 인증 접속하려는 사용자가 본인인지 확인하는 인증 절차 2️⃣ Authorization - 인가 / 권한 인증된 사용자가 요청한 자원에…","fields":{"slug":"/securityjwtlogin-0/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 0 [개요 - Spring Security Framework]","date":"December 01, 2022"}},"next":{"fields":{"slug":"/KakaoBlind-2022-파괴되지않은건물/"}},"previous":{"fields":{"slug":"/securityjwtlogin-1/"}}},{"node":{"id":"7bdc0550-064a-51e5-87e0-4ab0d6f83275","excerpt":"Kakao Blind 2022 - 파괴되지 않은 건물 Level Ⅲ  Kakao Blind 2022 - 파괴되지 않은 건물  문제  2차원 배열에서 특정 구간에 덧셈, 뺄셈을 진행하고 이를 효율적으로 시간 단축하는 문제입니다.   입력     출력  단순히 더하고 빼는 연산을  에 해결하더라도 정확도는 쉽게 100% 맞출 수 있습니다. 하지만, 이 문제는 효율성 문제로 시간 복잡도를 줄여야 합니다.   🍺 How to Solve?  🔥 Key Point 어떻게 하면 구간에 대해서 더하고, 빼는 연산을 매번 하지 않고 한 번에 할 수 있을까?? 🎯 2차원 배열에서 누적합을 이용한다.  5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 위 상황에서 (3,3) 부터 (5,5) 까지 -4 만큼 적용한다면?    모든 구간에 적용할 필요 없이 각 사각형의 오른쪽 아래 끝 좌표에만 기록을 한다면\n\n(0,0) 부터 해당 구간까지에는 x만큼 적용하겠다는 의…","fields":{"slug":"/KakaoBlind-2022-파괴되지않은건물/"},"frontmatter":{"categories":"Algorithm DP 2D-Array-DP","title":"Kakao Blind 2022 - 파괴되지 않은 건물 [Kakao Blind 문제 - DP, 2D Array DP]","date":"October 13, 2022"}},"next":{"fields":{"slug":"/boj-2632-피자판매/"}},"previous":{"fields":{"slug":"/securityjwtlogin-0/"}}},{"node":{"id":"258aee53-2060-5c5d-a186-ea43ce3a7348","excerpt":"BOJ 2632 - 피자 판매 Gold Ⅱ  BOJ 2632 - 피자 판매  문제  고객이 두 종류의 피자 A와 B를 취급하는 피자가게에서 피자를 주문하고자 한다. <그림 1>과 같이 각 종류의 피자는 다양한 크기의 여러 개의 피자조각으로 나누어져 있다. 각 조각에 쓰여진 숫자는 피자조각의 크기를 나타낸다. 그림1 고객이 원하는 피자의 크기를 이야기하면, 피자가게에서는 한 종류의 피자를 2 조각 이상 판매할 때는 반드시 연속된 조각들을 잘라서 판매한다. 이때 판매한 피자조각의 크기 합이 주문한 크기가 되어야 한다. 판매한 피자조각은 모두 A종류이거나, 모두 B종류이거나, 또는 A와 B 종류가 혼합될 수 있다. 예를 들어서, <그림 1> 과 같이 잘라진 피자가 있을 때, 손님이 전체 크기가 7 인 피자를 주문하면, 피자 가게에서는 <그림2>와 같이 5 가지 방법으로 피자를 판매할 수 있다. 그림2 피자가게에서 손님이 원하는 크기의 피자를 판매하는 모든 방법의 가지 수를 계산하는 프로…","fields":{"slug":"/boj-2632-피자판매/"},"frontmatter":{"categories":"Algorithm DP Segment-Tree","title":"BOJ 2632 - 피자 판매 [BOJ 문제 - DP, Segment Tree]","date":"October 13, 2022"}},"next":{"fields":{"slug":"/boj-2263-트리의순회/"}},"previous":{"fields":{"slug":"/KakaoBlind-2022-파괴되지않은건물/"}}},{"node":{"id":"b75b9cd2-ad66-5e42-b7d8-21a58891e51c","excerpt":"BOJ 2263 - 트리의 순회 Gold Ⅱ  BOJ 2263 - 트리의 순회  문제  n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 줄에는 인오더를 나타내는 n개의 자연수가 주어지고, 그 다음 줄에는 같은 식으로 포스트오더가 주어진다.   출력  첫째 줄에 프리오더를 출력한다.   ✨ PreOrder, PostOrder, InOrder란?  전위 순회, 후위 순회, 중위 순회이다. 이는 Tree에서의 traversal인데, 전위는 노드 왼쪽에서 방문하고, 중위는 노드 아래에서 만나고, 후위는 노드 오른쪽에서 만난다.  이를 그림으로 보면 이해하기 쉽다. 1️⃣ PreOrder Traversal    2️⃣ InOrder Traversal    1️⃣ PostOrder Traver…","fields":{"slug":"/boj-2263-트리의순회/"},"frontmatter":{"categories":"Algorithm Divide&Conquer","title":"BOJ 2263 - 트리의 순회 [Divide & Conquer]","date":"August 30, 2022"}},"next":{"fields":{"slug":"/start-blog/"}},"previous":{"fields":{"slug":"/boj-2632-피자판매/"}}},{"node":{"id":"bed59852-645f-5335-bb9d-54a6b907492e","excerpt":"알고리즘 문제와 프로젝트를 진행하며 겪는 어려움들을 기록할 블로그. 기존의 Jekyll 블로그를 이용하다가\n\nGraphQL 기반으로, 빠르게 동작하고 앞으로 Web 을 학습해 나갈 것이기 때문에, 스스로 Custom을 해보고 싶은 마음에 Gatsby 기반의 블로그로 이전하게 되었습니다.\n ✨ 이 블로그는 ZoomKoding 님의 블로그 테마를 사용했습니다. ZoomKoding  💥 ZoomKoding Blog theme Custom  줌코딩님의 테마를 사용하며 약간의 수정을 하고 싶어 코드를 살짝 변경했습니다. react를 사용할 줄 모르기 때문에 간단한 변경이지만 완벽하게 수정하지 못했지만, custom 한 부분을 기록하고자 합니다.  1️⃣ Blog Custom - Category  기존 카테고리는 아래와 같은 형태였습니다.\n  여기에서 제가 변경하고 싶은 부분을 먼저 말씀드리겠습니다.\n\n1️⃣ 처음 Focus되는 태그는 All 로 변경 \n2️⃣ 모든 태그 표기 \n3️⃣ 태그 사전 순 정렬이…","fields":{"slug":"/start-blog/"},"frontmatter":{"categories":"Blog","title":"Coding Blog Transfer","date":"August 15, 2022"}},"next":{"fields":{"slug":"/start-java/"}},"previous":{"fields":{"slug":"/boj-2263-트리의순회/"}}},{"node":{"id":"f9f71fc8-1b41-576c-bd7a-00fd98f4d371","excerpt":"기존에는 Python으로 알고리즘 문제를 풀어왔지만, 이번 포스팅부터 JAVA로 전환하고자 하고자 합니다.  그 이유로는 크게 두 가지 이유가 존재합니다. \n1️⃣ Web BackEnd 개발자.\n\n기존에는 원래 많이 사용했던 Python이 익숙해 알고리즘 문제 풀 때 자연스럽게 Python을 사용했습니다. 하지만, 본격적으로 Web BackEnd 개발자를 목표로 공부하며 자바에 익숙해지고 있었습니다. \n2️⃣ SSAFY 8기 참여\n\nSSAFY 8기에 Java Web 과정에 참여하게 되면서 완전히 전환을 하고자 합니다. 공부하고 있는 Framework도 Spring이고 취업 또한, Java 기반의 Spring Framework를 사용하는 회사에 지원할 예정이기 때문에, Python 보다는 회사에서 사용하는 언어인 Java로 코딩테스트를 보는 것이 아무래도 조금이나마 유리하다고 생각되어 전환하고자 합니다.  아직은 Python에 비해 library 도 불편함이 많은 것 같고, 자료구조의 시간…","fields":{"slug":"/start-java/"},"frontmatter":{"categories":"Algorithm Java","title":"Algorithm 문제 풀이 Java로 전환","date":"August 10, 2022"}},"next":{"fields":{"slug":"/boj-1102-발전소/"}},"previous":{"fields":{"slug":"/start-blog/"}}},{"node":{"id":"dbb0135d-a24b-5e45-a050-9bef443a4a48","excerpt":"BOJ 1102 - 발전소 Gold-Ⅰ  이 문제는 BOJ 문제입니다. 문제 출처 : 발전소  💥 문제 \n은진이는 발전소에서 근무한다. 은진이가 회사에서 잠깐 잘 때마다, 몇몇 발전소가 고장이난다. 게다가, 지금 은진이의 보스 형택이가 은진이의 사무실로 걸어오고 있다. 만약 은진이가 형택이가 들어오기 전까지 발전소를 고쳐놓지 못한다면, 은진이는 해고당할 것이다. \n발전소를 고치는 방법은 간단하다. 고장나지 않은 발전소를 이용해서 고장난 발전소를 재시작하면 된다. 하지만, 이때 비용이 발생한다. 이 비용은 어떤 발전소에서 어떤 발전소를 재시작하느냐에 따라 다르다. \n적어도 P개의 발전소가 고장나 있지 않도록, 발전소를 고치는 비용의 최솟값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 발전소의 개수 N이 주어진다. N은 16보다 작거나 같은 자연수이다. \n둘째 줄부터 N개의 줄에는 발전소 i를 이용해서 발전소 j를 재시작할 때 드는 비용이 주어진다. \ni줄의 j번째 값이 그 값…","fields":{"slug":"/boj-1102-발전소/"},"frontmatter":{"categories":"Algorithm BitMasking DP BFS DFS","title":"BOJ 1102 - 발전소 [BOJ 문제 - BitMasking, DP, BFS, DFS]","date":"June 08, 2022"}},"next":{"fields":{"slug":"/boj-1194-달이차오른다가자/"}},"previous":{"fields":{"slug":"/start-java/"}}},{"node":{"id":"7fe3add6-46d4-5035-bf60-615eb04ea45d","excerpt":"BOJ 1194 - 달이 차오른다, 가자. Gold-Ⅰ  이 문제는 BOJ 문제입니다. 문제 출처 : 달이 차오른다, 가자.  문제  지금 민식이가 계획한 여행은 달이 맨 처음 뜨기 시작할 때 부터, 준비했던 여행길이다. 하지만, 매번 달이 차오를 때마다 민식이는 어쩔 수 없는 현실의 벽 앞에서 다짐을 포기하고 말았다. 민식이는 매번 자신의 다짐을 말하려고 노력했지만, 말을 하면 아무도 못 알아들을 것만 같아서, 지레 겁먹고 벙어리가 되어버렸다. 결국 민식이는 모두 잠든 새벽 네시 반쯤 홀로 일어나, 창 밖에 떠있는 달을 보았다. 하루밖에 남지 않았다. 달은 내일이면 다 차오른다. 이번이 마지막기회다. 이걸 놓치면 영영 못간다. 영식이는 민식이가 오늘도 여태것처럼 그냥 잠 들어버려서 못 갈지도 모른다고 생각했다. 하지만 그러기엔 민식이의 눈에는 저기 뜬 달이 너무나 떨렸다. 민식이는 지금 미로 속에 있다. 미로는 직사각형 모양이고, 여행길을 떠나기 위해 미로를 탈출하려고 한다. 미…","fields":{"slug":"/boj-1194-달이차오른다가자/"},"frontmatter":{"categories":"Algorithm BFS BitMasking","title":"BOJ 1194 - 달이 차오른다, 가자. [BOJ 문제 - BFS, BitMasking]","date":"June 03, 2022"}},"next":{"fields":{"slug":"/boj-17471-게리맨더링/"}},"previous":{"fields":{"slug":"/boj-1102-발전소/"}}},{"node":{"id":"f47855c0-fc14-51be-b340-301837b7c34d","excerpt":"BOJ 17471 - 게리맨더링 Gold-Ⅳ  이 문제는 BOJ 문제입니다. 문제 출처 : 게리맨더링  문제 \n백준시의 시장 최백준은 지난 몇 년간 게리맨더링을 통해서 자신의 당에게 유리하게 선거구를 획정했다. 견제할 권력이 없어진 최백준은 권력을 매우 부당하게 행사했고, 심지어는 시의 이름도 백준시로 변경했다. 이번 선거에서는 최대한 공평하게 선거구를 획정하려고 한다.\n\n백준시는 N개의 구역으로 나누어져 있고, 구역은 1번부터 N번까지 번호가 매겨져 있다. 구역을 두 개의 선거구로 나눠야 하고, 각 구역은 두 선거구 중 하나에 포함되어야 한다. 선거구는 구역을 적어도 하나 포함해야 하고, 한 선거구에 포함되어 있는 구역은 모두 연결되어 있어야 한다. 구역 A에서 인접한 구역을 통해서 구역 B로 갈 수 있을 때, 두 구역은 연결되어 있다고 한다. 중간에 통하는 인접한 구역은 0개 이상이어야 하고, 모두 같은 선거구에 포함된 구역이어야 한다.\n\n아래 그림은 6개의 구역이 있는 것이고…","fields":{"slug":"/boj-17471-게리맨더링/"},"frontmatter":{"categories":"Algorithm BitMasking BFS","title":"BOJ 17471 - 게리맨더링 [BOJ 문제 - BitMasking, BFS]","date":"May 21, 2022"}},"next":{"fields":{"slug":"/swea-14362-무한로봇/"}},"previous":{"fields":{"slug":"/boj-1194-달이차오른다가자/"}}},{"node":{"id":"61ee2b86-71e1-59ab-8260-b15ab1da9280","excerpt":"SWEA 14362 - 무한 로봇 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 무한 로봇  🔥 주의할 점  k번째로 명령을 수행한 직후의 위치를 라고 할 때, 는 모든 좌표를 의미한다. 로봇이 이동을 마치고 난 후의 점이 아닌 이동 중 마주한 모든 정수 좌표들을 의미한다.  💥 How to Solve?  결과부터 말하자면, 테스트 케이스는 125개, 최대 움직임은 2500회이다. \n내가 구현한 방법은 움직임이 Worst Case인 경우 총 4번을 반복해야하니 10000회 이루어지고, \n모든 TC가 10000회 이루어진다해도 125만회로 제한 시간 3초 이내에 해결할 수 있다고 판단해 단순 구현 방법으로 해결했다.  ‼ Point ‼  우선 용어 몇 가지를 정의하고 시작한다. | ➡ | ⬇ | ⬅ | ⬆ | ➡ | \n움직임 : 로봇이 움직인 방향을 기록한 데이터\n초기 방향 : Right\n시작 방향 : 첫 움직임 방향 - ex) RS 라고 한다면 맨 처음 Right에서 오른…","fields":{"slug":"/swea-14362-무한로봇/"},"frontmatter":{"categories":"Algorithm Implementation Geometry","title":"SWEA 14362 - 무한 로봇 [SWEA 문제 - Implementation, Geometry]","date":"May 20, 2022"}},"next":{"fields":{"slug":"/swea-4111-무선단속카메라/"}},"previous":{"fields":{"slug":"/boj-17471-게리맨더링/"}}},{"node":{"id":"0e484e3f-6dc5-58e6-bc04-359a7c911fd9","excerpt":"SWEA 4111 - 무선 단속 카메라 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 무선 단속 카메라\n 🔥 Point  이 문제의 핵심은 Kruskal 알고리즘에서 아이디어를 떠올렸다. \nKruskal 알고리즘은 MST(Minimum Spanning Tree)를 만들기 위한 알고리즘 중 하나이다. \nMST란 최소 비용으로 만들 수 있는 Spanning Tree(신장 트리)를 찾는 알고리즘이다.  🌟 MST 찾기 위해서 Kruskal 알고리즘은 모든 간선 중 가장 비용이 낮은 간선들부터 제거하며 해당 간선으로 이어져 있는 노드들끼리 합쳐주는 것 이다. 이를 이 문제에 적용해 해결할 것이다.  💥 How to Solve?  수신기는 모든 카메라들을 포함하고 있어야 한다. 이를 반대로 생각해봤다. 모든 카메라에 하나의 수신기들이 배당되어 있고, 가장 붙어있는 카메라들을 하나의 수신기가 담당하도록 한다. 이해를 위해 그림으로 살펴보자.\n 1️⃣ 최초에는 모든 카메라에 수신기를 부여…","fields":{"slug":"/swea-4111-무선단속카메라/"},"frontmatter":{"categories":"Algorithm Disjoin-Set Union-Find Set Kruskal","title":"SWEA 4111 - 무선 단속 카메라 [SWEA 문제 - Disjoint-Set, Union-Find]","date":"May 20, 2022"}},"next":{"fields":{"slug":"/swea-4408-자기방으로돌아가기/"}},"previous":{"fields":{"slug":"/swea-14362-무한로봇/"}}},{"node":{"id":"5fc2bcef-f02a-5052-81e5-c93f4edbdaf1","excerpt":"SWEA 4408 - 자기 방으로 돌아가기 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 자기 방으로 돌아가기  💥 How to Solve?  1 3 5 7 .. .. .. .. 397 399 2 4 6 8 .. .. .. .. 398 400 1️⃣ 좌표 압축\n\n이 문제는 1-2, 3-4, 5-6, … 399-400 이 각자 한 쌍을 이룬다.  즉 1번 방에서 3번 방으로 이동하고, 4번 방에서 8번방으로 이동한다면 3-4 복도에서 겹친다는 결과가 나온다.  이를 이용해서 1-400의 좌표를 1-200 좌표로 압축했다.  홀수는 (odd+1)//2, 짝수는 (even//2) 를 통해서 1,2 좌표를 1로 압축하는 작업을 수행한다. 2️⃣ Line Sweeping 입력으로 들어온 구간에 이동하는 횟수를 기록한다. 즉, 입력으로 들어온 구간에 +1을 해준다. \n이 문제는 같은 방이 중복으로 등장하지 않고, 들어갔다 다시 나오는 작업들이 없기 때문에, 이동 횟수를 +1 씩 해주면 각 …","fields":{"slug":"/swea-4408-자기방으로돌아가기/"},"frontmatter":{"categories":"Algorithm Line-Sweeping Segment-Tree","title":"SWEA 4408 - 자기 방으로 돌아가기 [SWEA 문제 - Sweeping]","date":"May 20, 2022"}},"next":{"fields":{"slug":"/swea-6959-이상한나라의덧셈게임/"}},"previous":{"fields":{"slug":"/swea-4111-무선단속카메라/"}}},{"node":{"id":"605128eb-9686-5893-b622-cef0f203168c","excerpt":"SWEA 6959 - 이상한 나라의 덧셈게임 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 이상한 나라의 덧셈게임  💥 How to Solve?  이 문제는 1000자리 수까지 계산해야하기 때문에, 수 자체로 접근하게 되면 오류가 발생할 가능성이 매우 높다. \n\n처음에는 서로 최선의 수를 선택한다고 했기 때문에 Brute-Force 를 생각했다. 하지만 1000의 자리를 모두 고려하기에는 재귀의 깊이가 너무 깊어질 것 같다. \n\n그렇다면 남은 방법은 어떻게 효율적으로 판단할 수 있을지 고민해야한다. \n해결하지 못해 문제 아래 댓글을 통해 힌트를 얻고 쉽게 해결했다. \n\n123 이런 수가 있다고 한다면, 12를 합치면 33, 23을 합치면 15가 나온다.  두 자리의 합이 10을 넘지 않는 이상 자리 수가 줄어들게 되어있다.  그리고 다시 33이나 15를 합치게 되면 6으로 총합은 변하지 않는다. 78 을 살펴보자. 78을 합치면 15가 된다. 자리수는 줄어들지 않는다.  …","fields":{"slug":"/swea-6959-이상한나라의덧셈게임/"},"frontmatter":{"categories":"Algorithm Greedy","title":"SWEA 6959 - 이상한 나라의 덧셈게임 [SWEA 문제 - Greedy]","date":"May 17, 2022"}},"next":{"fields":{"slug":"/swea-10762-사탕나누기/"}},"previous":{"fields":{"slug":"/swea-4408-자기방으로돌아가기/"}}},{"node":{"id":"16cacb14-14bd-5978-80bc-9774c052f0db","excerpt":"SWEA 10762 - 사탕 나누기 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 사탕 나누기  💥 How to Solve?  편의상 동원이를 형이라 하고 그 동생을 동생이라고 칭한다. \n형은 동생보다 많은 사탕을 가지고 싶어하고 동생은 사탕 수를 XOR 연산을 통해서 계산한다. 각 사탕 봉지안의 사탕 수를  이라고 할 때, 동생 기준으로는  이런 식이 나와야 한다. 우선 이 문제의 핵심은 XOR 연산자이다. XOR 연산자의 경우 비트간 서로 다른 경우에만 1이 된다. 즉 위와 같은 연산,  의 결과가 나온다. XOR 연산의 특징 하나를 알면 굉장히 쉽게 해결할 수 있다.\n XOR 연산은  이라면 위와 같은 특징을 이용한다면 굉장히 쉽게 해결할 수 있다.  주어진 모든 수들을 XOR 한 결과를 통해 그 결과가 0이라면\n 동생에게 최소 사탕 봉지 딱 하나만 넘겨주고 나머지는 형이 독식한다해도 동생의 기준으로는 공평한 배분이 된다.  ✨ Python Code  💥 끝!! ✨ …","fields":{"slug":"/swea-10762-사탕나누기/"},"frontmatter":{"categories":"Algorithm Bitwise-Operation","title":"SWEA 10762 - 사탕 나누기 [SWEA 문제 - 비트 연산 활용 문제]","date":"May 16, 2022"}},"next":{"fields":{"slug":"/swea-4699-콩순이의 가장 싼 팰린드롬/"}},"previous":{"fields":{"slug":"/swea-6959-이상한나라의덧셈게임/"}}},{"node":{"id":"2af0eb8d-044d-5672-a71f-393e0812d915","excerpt":"SWEA 4699 - 콩순이의 가장 싼 팰린드롬 D-Ⅳ  이 문제는 SWEA 문제입니다. 문제 출처 : 콩순이의 가장 싼 팰린드롬  Palindrome 이란? 팰린드롬이란 문자열, DP 문제에서 종종 접할 수 있는 문제이다. 팰린드롬을 가장 쉽게 표현하자면 거꾸로 해도 똑같은 문자라고 할 수 있다. 예를 들어, ABBA 와 같이 거꾸로 해도 똑같은 문자를 의미한다.\n How to Solve?  처음에는 문자를 제거하고 삽입하는 모든 경우를 탐색하면서 팰린드롬이 완성됐다면 Cost 값을 저장해두고 해당 Cost보다 큰 경우는 바로 탐색 종료하는 방식의 BackTracking 방식으로 구현했다.  하지만 이 문제의 Stack 메모리 제한이 있기에 재귀로 해결하기 어렵다. 따라서 다른 방식의 접근이 필요하다. 앞서 Palindrome을 설명하면서 DP에서 자주 나온다고 설명했다. 따라서 이 문제에서도 DP를 활용한 접근 방법을 알아본다.  🔥 DP  핵심은 가장 인접한 두 글자부터 팰린…","fields":{"slug":"/swea-4699-콩순이의 가장 싼 팰린드롬/"},"frontmatter":{"categories":"Algorithm Palindrome DP","title":"SWEA 4699 - 콩순이의 가장 싼 팰린드롬 [SWEA 문제 - 팰린드롬, DP]","date":"May 15, 2022"}},"next":{"fields":{"slug":"/cia-rsa/"}},"previous":{"fields":{"slug":"/swea-10762-사탕나누기/"}}},{"node":{"id":"b6b1f7a0-2111-504c-9a0b-24ef832f39a5","excerpt":"보안의 3요소 CIA와 RSA  해당 내용은 메타코딩 - 스프링부트 시큐리티 강의를 들으며 정리한 내용입니다. TCP 통신이 갖고 있는 보안상의 문제점에 대해 살펴보고 RSA 인증 방법을 살펴본다. Web은 TCP 프로토콜을 이용하기 때문에 어떠한 보안상의 문제가 있고, 이를 해결하기 위해 어떤 방식을 사용할 수 있는지는 중요한 내용이다.  보안의 3요소 - CIA 💥 Confidentiality - 기밀성  \nC를 해커라 했을 때, 해커가 중간에 데이터를 가로챌 수 있다. - 기밀성이 깨진다. 💥 Integrity & Available - 무결성 & 가용성  \nC가 가로채 위조 데이터를 전송하게 되면 데이터의 무결성이 꺠지고, B는 제대로 된 데이터를 받지 못해 가용성이 깨진다.  1️⃣ : Key를 뺏기면 기밀성 위배 2️⃣ : Key를 뺏기면 무결성 위배 3️⃣ : 수신자가 Key가 없다면 가용성 위배 ⚒ Key를 수신자가 가지고 있어야 하기 때문에, 열쇠 전달의 문제도 발생한다. 🔥 …","fields":{"slug":"/cia-rsa/"},"frontmatter":{"categories":"Network TCP CIA RSA TIL","title":"TCP 통신의 보안 - TCP, CIA, RSA","date":"May 12, 2022"}},"next":{"fields":{"slug":"/jwt-structure/"}},"previous":{"fields":{"slug":"/swea-4699-콩순이의 가장 싼 팰린드롬/"}}},{"node":{"id":"f4488efe-1b19-5d76-a197-1371b6d80d0f","excerpt":"JWT - Json Web Token  해당 내용은 메타코딩 - 스프링부트 시큐리티 강의를 들으며 정리한 내용입니다. JWT는 Json Web Token으로 Web에서 Json 객체로 정보를 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다. ⚒ 여기에서 RFC란 여러 내부망들이 서로 연결할 때, 서로 약속된 규칙으라고 생각하면 된다.  JWT는 언제 사용할까?  JWT 구조 xxxxx.yyyyy.zzzzz xxxxx : Header yyyyy : Payload zzzzz : Signature 💥 Header : 토큰 유형, 서명 알고리즘  💥 Payload : 엔티티(사용자) 및 추가 데이터에 대한 설명  💥 Payload : 엔티티(사용자) 및 추가 데이터에 대한 설명  Header, Payload, Signature 를 종합해 보면 다음과 같다. header부분은 header에 해당하는 값이 인코딩 된 값이고, Payload는 Payload에 해당하는 값이 인코딩 된 …","fields":{"slug":"/jwt-structure/"},"frontmatter":{"categories":"JWT Login TIL","title":"JWT 구조 - JWT Structure & 장점","date":"May 12, 2022"}},"next":{"fields":{"slug":"/osi7Layer/"}},"previous":{"fields":{"slug":"/cia-rsa/"}}},{"node":{"id":"7882d6b1-642f-541b-aca0-83a6d053680c","excerpt":"Open Systems Interconnection 7 Layer  OSI 7계층이란? 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 개방형 시스템 상호 연결 모델의 표준이다.  OSI 7계층 분리 이유 모든 시스템들의 상호 연결에 있어 문제 없도록 표준을 정함. 계층을 나눠 통신이 일어나는 과정을 단계별로 확인할 수 있음. 장점 : 7계층 중 특정 Layer에 이상이 생기면 다른 장비 및 SW는 유지하고 해당 Layer 장비만 교체하면 된다.  OSI 7계층 구조    응용 프로그램에서 다른 응용 프로그램으로의 통신을 위해 빨간색 화살표를 따라 통신이 이루어진다. 송신자의 관점으로 설명을 진행한다.  💥 7계층 : Application Layer - 응용 계층 응용 프로세서 간의 정보 교환을 담당한다. \n여기에서 중요한 점은 응용 계층은 응용 프로그램이 아니다. HTTP와 같은 프로토콜이 여기에 해당한다. \n⚒ 대표적으로 HTTP (HyperText Transfer Proto…","fields":{"slug":"/osi7Layer/"},"frontmatter":{"categories":"Network OSI-7계층 TIL","title":"OSI 7계층 - 통신 Open Systems Interconnection 7 Layer","date":"May 12, 2022"}},"next":{"fields":{"slug":"/tcp-udp/"}},"previous":{"fields":{"slug":"/jwt-structure/"}}},{"node":{"id":"acbef66e-b5ed-5058-8f8c-608e15079263","excerpt":"TCP VS UDP  💥 TCP - Transmission Control Protocol 우선 간단한 그림을 통해 TCP의 데이터 송신 과정을 살펴보자.\n   ✔ ACK(확인 신호)를 응답받아야 다음 메세지를 전송하고 응답을 받지 못하면 재전송을 한다. 이러한 특징때문에 신뢰성 이 높지만 속도가 비교적 느리다. TCP 특징 1️⃣ : 연결형 서비스 3-Way Handshaking 과정을 통해 연결한다. 4-Way Handshaking 과정을 통해 연결을 해제한다. 3-Way Handshaking   1️⃣ : Client가 서버에 접속을 요청하는 SYN 패킷을 전송한다. \n2️⃣ : 서버는 Client에게 SYN 요청을 받고 Client에게 요청을 수락하는 ACK 와 SYN flag가 설정된 패킷을 전송한다. Client가 다시 ACK을 응답하기를 기다린다. \n3️⃣ : Client는 서버에게 ACK 응답을 전송하고 연결이 서로 이루어진다. 이후 데이터가 오고 간다.\n 4-Way Handshak…","fields":{"slug":"/tcp-udp/"},"frontmatter":{"categories":"Network TCP UDP TIL","title":"TCP/UDP 통신 [통신 - TCP/UDP]","date":"May 12, 2022"}},"next":{"fields":{"slug":"/session-login/"}},"previous":{"fields":{"slug":"/osi7Layer/"}}},{"node":{"id":"9cf89c1a-d082-5d6d-aeea-11ba4ba4a07c","excerpt":"Session Login  해당 내용은 메타코딩 - 스프링부트 시큐리티 강의를 들으며 정리한 내용입니다.\n JWT(Json Web Token)을 살펴보기 전에 왜 JWT를 쓰고 어디에 사용되는지 확인하기 위해 먼저 Session Login을 알아보고 어떤 문제점들이 있는지 확인해보자. 우선 서버 Session은 Client가 최초 접근시 서버의 Session ID 목록을 관리하는 곳에 자동으로 해당 브라우저에 대한 세션 ID를 생성해 관리하게 된다. 생성된 Session ID를 html 반환시 헤더(쿠키)에 담아 전달하고 이후 두 번째 접근부터는 이 세션 ID가 포함된 요청이 서버로 들어오게 된다. 💥 Session을 왜 사용할까? 이러한 특징을 Stateful 이라고 한다.  Session 기반 Login 세션 기반 로그인을 그림을 통해 확인해 본다.  \n 3️⃣-4️⃣ : 생성된 세션 ID를 쿠키에 담아 클라이언트에게 전달하고 클라이언트는 이 세션 ID를 저장해둔다.  5️⃣-7️⃣ : Lo…","fields":{"slug":"/session-login/"},"frontmatter":{"categories":"JWT Session Login TIL","title":"Session Login - JWT 로그인에 앞선 Session Login","date":"May 11, 2022"}},"next":{"fields":{"slug":"/swea-10805-야바위/"}},"previous":{"fields":{"slug":"/tcp-udp/"}}},{"node":{"id":"5546081f-4cb7-5c9b-9807-da6ef8fee882","excerpt":"SWEA 10805 - 야바위 D-Ⅳ \n이 문제는 SW Expert Academy 문제입니다. SWEA 10805 - 야바위  문제  동호는 공과 N개의 컵을 가지고 야바위를 하고 있다. N개의 컵은 모두 구별이 가능하고, 일렬로 늘어서 있다. 처음에 왼쪽에서 첫 번째 컵에 공을 넣어놓는다. 그리고 앞으로 Q번 두 컵의 위치를 바꾸는데, i번째에는 왼쪽에서 Ai번째 컵과 왼쪽에서 Bi번째 컵의 위치를 바꾼다. 동호는 공이 어떤 컵에 있는지 맞출 수 없도록 하기 위해 정확히 한 번 속임수를 쓰려고 한다. 속임수는 현재 공이 들어있는 컵이 왼쪽에서 i번째 컵이라고 할 때, 왼쪽에서 i-1번째 컵이나 왼쪽에서 i+1번째 컵으로 공을 순간 이동시키는 것이다. 이 속임수는 컵을 섞는 도중이 아니라면, 어떤 시점에도 가능하다.  입력 \n첫 번째 줄에 테스트 케이스의 수 T가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 두 정수 N,Q (1 ≤ N, Q ≤ 105)가 공백 하나로 구분되어 주…","fields":{"slug":"/swea-10805-야바위/"},"frontmatter":{"categories":"Algorithm DP","title":"SWEA 10805 - 야바위 [Algorithm, DP]","date":"April 30, 2022"}},"next":{"fields":{"slug":"/boj-1941-소문난칠공주/"}},"previous":{"fields":{"slug":"/session-login/"}}},{"node":{"id":"00b778ac-604e-5723-b301-0cfe2045fcfd","excerpt":"BOJ 1941 - 소문난 칠공주 Gold Ⅲ  BOJ 1941 - 소문난 칠공주  문제  총 25명의 여학생들로 이루어진 여학생반은 5×5의 정사각형 격자 형태로 자리가 배치되었고,\n얼마 지나지 않아 이다솜과 임도연이라는 두 학생이 두각을 나타내며 다른 학생들을 휘어잡기 시작했다. 곧 모든 여학생이 ‘이다솜파’와 ‘임도연파’의 두 파로 갈라지게 되었으며, 얼마 지나지 않아 ‘임도연파’가 세력을 확장시키며 ‘이다솜파’를 위협하기 시작했다. \n위기의식을 느낀 ‘이다솜파’의 학생들은 과감히 현재의 체제를 포기하고, ‘소문난 칠공주’를 결성하는 것이 유일한 생존 수단임을 깨달았다. ‘소문난 칠공주’는 다음과 같은 규칙을 만족해야 한다.  이름이 이름인 만큼, 7명의 여학생들로 구성되어야 한다. 강한 결속력을 위해, 7명의 자리는 서로 가로나 세로로 반드시 인접해 있어야 한다. 화합과 번영을 위해, 반드시 ‘이다솜파’의 학생들로만 구성될 필요는 없다. 그러나 생존을 위해, ‘이다솜파’가 …","fields":{"slug":"/boj-1941-소문난칠공주/"},"frontmatter":{"categories":"Algorithm Brute-Force DFS Combination","title":"BOJ 1941 - 소문난 칠공주 [Algorithm, Brute-Force, DFS, Combination]","date":"April 28, 2022"}},"next":{"fields":{"slug":"/boj-9015-정사각형/"}},"previous":{"fields":{"slug":"/swea-10805-야바위/"}}},{"node":{"id":"31abffe0-77b9-5dd3-8f91-63a47a9c5067","excerpt":"BOJ 9015 - 정사각형 Gold Ⅰ  BOJ 9015 - 정사각형  문제  평면 위에 N개의 점이 주어졌을 때, 가장 큰 정사각형의 넓이를 구하여라.\n 문제 그림\n  입력 \n첫째 줄에 테스트케이스의 개수 T가 주어진다. 각 테스트케이스의 첫째 줄에는 점의 개수 N(4 ≤ n ≤ 3,000)이 주어지고, 이어서 N개의 줄에는 점의 x좌표와 y좌표가 주어진다. 모든 좌표는 -10000 이상 +10000이하의 정수이다. 같은 위치의 점이 여러 번 주어지는 경우는 없다.   출력 \n각 테스트 케이스마다 가장 큰 정사각형의 넓이를 한 줄에 하나씩 출력한다. 단, 정사각형이 없는 경우 0을 출력한다.   How to Solve?  점 4개를 선택해 정사각형 여부 확인하는 방법은\n\n로 불가능하다.  그래서 처음 생각했던 방법은 대각선 두 개를 선택해 두 대각선의 길이가 같고, 두 대각선의 기울기를 a1, a2라 했을 때,  즉 직교한다는 성질을 이용해 해결하려고 했다. 하지만 이 또한, …","fields":{"slug":"/boj-9015-정사각형/"},"frontmatter":{"categories":"Algorithm Data-Structure Geometry","title":"BOJ 9015 - 정사각형 [Data Structure, Geometry]","date":"April 27, 2022"}},"next":{"fields":{"slug":"/boj-2140-지뢰찾기/"}},"previous":{"fields":{"slug":"/boj-1941-소문난칠공주/"}}},{"node":{"id":"1f918123-0dc3-5aec-a8ab-e505719e5457","excerpt":"BOJ 2140 - 지뢰찾기 Gold Ⅴ  BOJ 2140 - 지뢰찾기  문제 지뢰찾기는 N×N에서 이뤄지는 게임이다. 보드의 곳곳에는 몇 개의 지뢰가 숨겨져 있고, 지뢰가 없는 칸에는 그 칸과 인접(상하좌우 및 대각선)해 있는 8개의 칸들에 몇 개의 지뢰가 숨겨져 있는지에 대한 정보가 주어진다. 게이머는 게임을 진행하면서 보드의 칸을 하나씩 열게 된다. 만약 그 칸에 지뢰가 있다면 게임이 끝나고, 없는 경우에는 그 칸에 적혀있는 숫자, 즉 그 칸과 인접해 있는 8개의 칸들 중 몇 개의 칸에 지뢰가 있는지를 알 수 있게 된다. 이 문제는 보드의 테두리가 모두 열려있고, 그 외는 모두 닫혀있는 상태에서 시작한다. 예를 들어 다음과 같은 경우를 보자. 1 1 1 0 0 2 # # # 1 3 # # # 1 2 # # # 1 1 2 2 1 0 #는 닫혀있는 칸을 나타낸다. 이러한 보드가 주어졌을 때, 닫혀있는 칸들 중 최대 몇 개의 칸에 지뢰가 묻혀있는지 알아내는 프로그램을 작성하시오. …","fields":{"slug":"/boj-2140-지뢰찾기/"},"frontmatter":{"categories":"Algorithm Implementation Greedy","title":"BOJ 2140 - 지뢰찾기 [Implementation, Greedy]","date":"April 24, 2022"}},"next":{"fields":{"slug":"/boj-17947-상남자곽철용/"}},"previous":{"fields":{"slug":"/boj-9015-정사각형/"}}},{"node":{"id":"9444efde-5987-5c6c-baef-87ebfecf669a","excerpt":"BOJ 17947 - 상남자 곽철용 Gold Ⅰ  BOJ 17947 - 상남자 곽철용  문제 우리의 우상 곽철용은 화투로 노름을 하는 것을 매우 좋아한다. 이번에 그는 지인들과 함께 새로운 게임을 해보려고 한다. 게임은 M명의 참가자로 진행되며, 4 × N장의 카드를 가지고 한다. 카드에 적힌 숫자는 1부터 4 × N까지의 수이며, 중복되는 숫자가 적힌 카드는 존재하지 않는다. M명의 참가자들은 우선 4 × N장의 카드에서 각각 2개의 카드를 뽑아서 버린다. 그리고 다시 M명의 참가자들은 각각 2개의 카드를 뽑는다. 게임의 승부는 두번째에 뽑은 두 장의 카드에 적힌 숫자에 따라 결정된다. 각 참가자의 점수는 두 장의 카드에 적힌 숫자를 K로 나눈 나머지의 차이다. 곽철용은 두번의 카드 뽑기 후, 초조한 마음에 자신이 이 게임에서 이길 수 있는지 매우 궁금해졌다. 그래서 자신보다 점수가 높은 사람들이 최대 몇 명인지 알고자 한다. 여러분들이 상남자 곽철용의 초조한 마음을 풀어주도록 …","fields":{"slug":"/boj-17947-상남자곽철용/"},"frontmatter":{"categories":"Algorithm Greedy Two-Pointer","title":"BOJ 17497 - 상남자 곽철용 [Greedy, Two Pointer]","date":"April 20, 2022"}},"next":{"fields":{"slug":"/boj-23291-어항정리/"}},"previous":{"fields":{"slug":"/boj-2140-지뢰찾기/"}}},{"node":{"id":"de485fb0-2363-51cd-ae0f-78a04795dc38","excerpt":"BOJ 23291 - 어항정리 Platinum Ⅴ  BOJ 23291 - 어항정리  💥 Rule  1. 물고기 추가 - add_fish() 가장 적은 수의 물고기가 담긴 모든 어항에 물고기 한 마리씩 추가한다.\n 배열을 순회하면서 min 값을 갖는 인덱스를 모두 저장해둔다.\n 해당 인덱스에 해당하는 어항에 물고기 한 마리씩 추가한다.  ✨ Python Code  2. 어항 쌓기 - stack_bowl() 세로 배열과 가로 배열로 구분해서 관리할 것이다.\n 모든 세로 배열의 끝에서부터의 원소들과 가로 배열의 첫 번째부터의 원소들이 짝을 이뤄 새로운 하나의 세로 배열을 생성하게 된다.\n 세로 배열 하나의 길이가 가로 배열의 길이보다 커질때까지 어항을 쌓을 수 있다. \n이해를 위해 그림을 추가한다.  ✨ Python Code  3. 물고기 조정하기 - balance() 각 어항들의 인접한 어항들간의 차이를 줄이는 과정이다. 인접한 어항들간의 차이를 diff 라 하고, diff를 5로 나…","fields":{"slug":"/boj-23291-어항정리/"},"frontmatter":{"categories":"Algorithm Implementation Simulation","title":"BOJ 23291 - 어항정리 [Implementation, Simulation]","date":"April 15, 2022"}},"next":{"fields":{"slug":"/boj-9320-금고열기/"}},"previous":{"fields":{"slug":"/boj-17947-상남자곽철용/"}}},{"node":{"id":"280d04ef-c71f-5d40-92df-db562aa9bb4c","excerpt":"BOJ 9320 - 금고열기 Gold Ⅲ  BOJ 9320 - 금고열기  문제 비밀 요원 상근이는 시리아의 화학 무기에 대한 정보를 보관하고 있는 금고를 열려고 한다. 금고를 열려면 금고에 암호를 입력해야 한다. 암호는 숫자 네 개로 이루어져 있다. 상근이는 시도해야 하는 암호의 목록을 가지고 있다. 목록에는 매우 많은 암호가 적혀있기 때문에, 암호가 될 수 없는 것을 미리 지우려고 한다. 올바른 암호는 24 조건을 만족한다. 암호를 이루는 수 네 개 사이에 덧셈, 뺄셈, 곱셈, 나눗셈, 괄호를 적절히 삽입해서 24를 만들 수 있을 때, 그 암호를 24 조건을 만족한다고 한다. 예를 들어, (4, 7, 8, 8)은 (7-8/8)*4 = 24이기 때문에, 24 조건을 만족한다. 하지만, (1, 1, 2, 4)나 (1, 1, 1, 1)과 같은 암호는 24 조건을 만족하지 않는다. 따라서, 이러한 암호는 시도해볼 필요가 없다. 가능한 암호가 모두 주어졌을 때, 24 조건을 만족하는지 안…","fields":{"slug":"/boj-9320-금고열기/"},"frontmatter":{"categories":"Algorithm Brute-Force Math","title":"BOJ 9320 - 금고열기 [수학, 조합론, 브루트포스를 활용해 해결]","date":"April 13, 2022"}},"next":{"fields":{"slug":"/boj-2042-구간합구하기/"}},"previous":{"fields":{"slug":"/boj-23291-어항정리/"}}},{"node":{"id":"4f0dd4a8-5642-5335-a23d-3d9494c798a3","excerpt":"문제 풀이에 앞서 Segment Tree에 대한 설명과 어떤 상황에 왜 사용하기 좋은지 먼저 설명하도록 한다. baekjoon님이 작성하신 글을 보고 정리한 내용입니다. ✨ Segment Tree 왜 사용할까? 구간 합과 변경을 반복 한다면? 1)구간 left, right가 주어질 때,  S의 값을 구하라. 2) i번째 수를 변경하라.  위의 1), 2) 과정을 반복한다면  loop 문을 통해 1) 식을 해결할 경우. S를 구하기 위해서 O(N) Time. 값을 변경하기 위해서 O(1) Time 총 M번이 반복된다면 O(NM) Time. DP를 이용해 해결할 경우 S를 구하기 위해서는 O(1) Time ex) l = 2, r = 5, then S = DP[5] - DP[1] 로 O(1) time 해결 가능하다.\n값을 변경하게 된다면 DP도 갱신이 되어야 한다. 따라서 O(N) Time\n총 M번 반복시 O(NM) Time.  이렇듯 loop문이나 DP로 해결하게 된다면 O(NM) T…","fields":{"slug":"/boj-2042-구간합구하기/"},"frontmatter":{"categories":"Algorithm Segment-Tree","title":"BOJ 2042 - 구간 합 구하기 [Algorithm - Segment Tree]","date":"April 05, 2022"}},"next":null,"previous":{"fields":{"slug":"/boj-9320-금고열기/"}}}],"categories":["All","OS","Memory","Paging","TIL","Spring-Security","Spring-Boot","Jwt","Login","Algorithm","DP","2D-Array-DP","Segment-Tree","Divide&Conquer","Blog","Java","BitMasking","BFS","DFS","Implementation","Geometry","Disjoin-Set","Union-Find","Set","Kruskal","Line-Sweeping","Greedy","Bitwise-Operation","Palindrome","Network","TCP","CIA","RSA","JWT","OSI-7계층","UDP","Session","Brute-Force","Combination","Data-Structure","Two-Pointer","Simulation","Math"]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}