{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/TIL","result":{"pageContext":{"currentCategory":"TIL","categories":["All","OS","Memory","Paging","TIL","Spring-Security","Spring-Boot","Jwt","Login","Algorithm","DP","2D-Array-DP","Segment-Tree","Divide&Conquer","Blog","Java","BitMasking","BFS","DFS","Implementation","Geometry","Disjoin-Set","Union-Find","Set","Kruskal","Line-Sweeping","Greedy","Bitwise-Operation","Palindrome","Network","TCP","CIA","RSA","JWT","OSI-7계층","UDP","Session","Brute-Force","Combination","Data-Structure","Two-Pointer","Simulation","Math"],"edges":[{"node":{"id":"45871712-2bf3-5269-a0c3-1e508fcc95d7","excerpt":"👩‍💻 OS - Memory Management (2) [Paging] 3️⃣ NonContiguous Memory Allocation - Paging, Segment 앞서 봤던 Contiguous Allocation은 외부 단편화 문제를 해결하기 위한 방법으로 NonContiguous Memory Allocation 방법들이 있습니다. 그 중 Paging과 Segment를 알아보겠습니다. Paging Paging 은 NonContiguous Allocation 방식이다. 고정된 크기로 메모리는 Frame, 프로세스는 Page로 분할하여 관리한다. 한 프로새스는 여러 Page로 나뉘고 main memory에서 필요한 page를 순서 관계없이 Frame에 mapping해준다.  Paging 장점 & 단점 장점 Physical memory를 frame 단위로 분할해 사용하기 때문에 External Fragment 발생할 일이 없다. 할당/해제 가 빠르다 Shared Page를 통해 자원을 쉽…","fields":{"slug":"/os-paging-1/"},"frontmatter":{"categories":"OS Memory Paging TIL","title":"OS - Memory Management (2) [Paging]","date":"January 01, 2023"}},"next":{"fields":{"slug":"/os-memory-management/"}},"previous":null},{"node":{"id":"05b7756f-ea82-5723-909d-d2e30b48b576","excerpt":"👩‍💻 OS - Memory Management (1) Preview  1️⃣ Background - Memory Mapping & Protection, MMU, Virtual Memory, Swapping\n 2️⃣ Contiguous Memory Allocation - Block 3️⃣ NonContiguous Memory Allocation - Paging, Segment  1️⃣ Background 🛡️Memory Mapping & Protection logical 주소를 physical 주소로 mapping 하고 Out Of Memory 관리 [ 메모리 접근 범위 관리 ] ®️ Base Register & Limit Register Base Register : Physical Address(RAM)의 시작 주소\n(Relocation Register) Limit Register : 현 프로그램이 사용할 수 있는 register의 마지막 주소 위 두 Register를 통해 Logical Addess…","fields":{"slug":"/os-memory-management/"},"frontmatter":{"categories":"OS Memory Paging TIL","title":"OS - Memory Management (1)","date":"December 31, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-6/"}},"previous":{"fields":{"slug":"/os-paging-1/"}}},{"node":{"id":"599e092c-bb76-5e6e-b155-0e2a6be490a6","excerpt":"SecurityJwtLogin - 6 [Login & Signup & logout]  Structure 💥 전반적인 구조는 아래 그림과 같이 작성될 예정입니다. - Controller - Service - Mapper 구조   content","fields":{"slug":"/securityjwtlogin-6/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 6 [Login & Signup & logout]","date":"December 06, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-5/"}},"previous":{"fields":{"slug":"/os-memory-management/"}}},{"node":{"id":"2343b1be-c8e6-5f1a-a42c-02b1b6709743","excerpt":"SecurityJwtLogin - 5 [JWT Filter & ExceptionHandler]  Spring Security Filter Spring-Security 는 Filter 기반으로 동작합니다. 큰 그림을 보면 아래 그림과 같습니다.  출처 : gngsn님 블로그 큰 흐름은 위와 같고, 이를 모두 이해하기엔 어려움이 있어 우선 당장 사용하는 기능들에 필요한 부분만 이용하겠습니다. UsernamePasswordAuthenticationFilter 🔥 기본적으로 Authentication(인증)을 담당하는 필터는 AbstractAuthenticationProcessingFilter이다. AbstractAuthenticationProcessingFilter는 추상 클래스로 SecurityFilterChain에 직접 들어갈 수 없습니다. UsernamePasswordAuthenticationFilter는 이를 상속받은 클래스이다. UsernamePasswordAuthenticat…","fields":{"slug":"/securityjwtlogin-5/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 5 [JWT Filter & ExceptionHandler]","date":"December 06, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-4/"}},"previous":{"fields":{"slug":"/securityjwtlogin-6/"}}},{"node":{"id":"5f54c138-b734-53cd-96f8-e6887a1954ae","excerpt":"SecurityJwtLogin - 4 [Token Provider]  Token Provider 토큰을 생성, 토큰으로부터 Authentication 생성, 유효성 검사 등의 작업을 수행할 Token Provider를 작성합니다. 이 때, 인스턴스가 생성되는 시점에 필요한 작업이 있습니다. 일반적으로 생성자가 호출될 때 수행합니다. 이 경우에 어떤 문제가 발생하는지 알아보겠습니다.  InitializingBean VS @PostConstruct 일반적인 생성자 호출 시점에 수행 🌈 SingleTon 으로 관리한다고 가정 new Foo() 를 수행하게 되면 Animal 이 등록되지 않았기 때문에 NULL 이 된다. 또한, Proxy 등의 이유로 Spring Framework에서 여러 번 호출될 수 있는 생성자이기 때문에 animal을 여러 번 출력하게 됩니다. 이를 생성자 주입과 @PostConstruct로 수정한 코드를 살펴보겠습니다. @PostConstruct 생성자 주입을 통해…","fields":{"slug":"/securityjwtlogin-4/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 4 [Token Provider]","date":"December 03, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-3/"}},"previous":{"fields":{"slug":"/securityjwtlogin-5/"}}},{"node":{"id":"d12e8094-4148-53ee-b596-ceefdaf736c9","excerpt":"SecurityJwtLogin - 3 [기본 Model 생성]  VO & DTO  User : 사용자 Entity Token : Token Entity Authority : 권한 정보 JwtResponseDto : 응답 DTO  User 권한의 경우 여러 권한을 가질 수 있으니 위와 같이 Collection으로 관리합니다.  JwtResponse 최초 발급 시 access token, refresh token 모두 발급해주고, 유저 아이디와 권한 정보를 함께 보내줬습니다. 토큰 외의 정보는 어떤 정보를 보내줄 것인가에 따라서 설정하면 됩니다. access token 재발급 시 토큰만 재발급해줬습니다. 🌈 모든 코드는 junhyxxn GitHub에서 확인할 수 있습니다!! VO & DTO User JwtResponse","fields":{"slug":"/securityjwtlogin-3/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 3 [기본 Model 생성]","date":"December 02, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-2/"}},"previous":{"fields":{"slug":"/securityjwtlogin-4/"}}},{"node":{"id":"100ea7c9-c919-5bd2-8ab5-c38344389337","excerpt":"SecurityJwtLogin - 2 [DB 설계]  MySQL DB 설계 ERD  단순한 프로젝트의 경우 User Table에 Authority 를 포함시키는 편이 더 간단합니다. 하지만, 복잡한 프로젝트의 경우 한 user가 여러 autority를 가질 수 있습니다. 예를 든다면, 강사가 존재하고 그 직속으로 조교라는 개념이 존재한다면 강사는 조교의 권한과 강사의 권한을 모두 갖게 됩니다. ⭐ 따라서, 위와 같이 한 유저가 여러 권한을 가질 수 있도록 ERD를 구성했습니다.  일반적으로 사용자별 권한 관리 방식과 그룹별 권한 관리 방식이 존재한다고 합니다. MySQL DB 설계 ERD","fields":{"slug":"/securityjwtlogin-2/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 2 [DB 설계]","date":"December 02, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-1/"}},"previous":{"fields":{"slug":"/securityjwtlogin-3/"}}},{"node":{"id":"b524e060-b47b-559d-8bb2-672a204fe189","excerpt":"SecurityJwtLogin - 1 [초기 프로젝트 설정]  Dependencies and Version  spring boot 의 경우 3.0.0 은 에러가 발생합니다. 따라서 2.7.6을 선택해줍니다. (되도록 SNAPSHOT은 피합니다.)  기본 설정 Dependency 를 추가할 때 설명이 적혀있지만 한 번 가볍게 살펴보겠습니다. Spring Web : Web 관련 Dependency Spring Boot DevTools : LiveReload 기능 제공 Lombok : Annotation 을 통해 Getter, Setter, Constructor 등을 사용가능 하도록 제공 Spring Security : 인증, 인가 등의 보안을 처리하기에 편리하도록 제공하는 Framework MyBatis Framework : Persistence Framework로 DB에 접근할 Connection Pool 등을 담당하고 SQL을 준비할 프레임워크 MySQL Driver : MySQL…","fields":{"slug":"/securityjwtlogin-1/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 1 [프로젝트 설정]","date":"December 01, 2022"}},"next":{"fields":{"slug":"/securityjwtlogin-0/"}},"previous":{"fields":{"slug":"/securityjwtlogin-2/"}}},{"node":{"id":"45b7be86-c7ff-58c8-840b-768519a67392","excerpt":"SecurityJwtLogin - 0 [개요 - Spring Security Framework]  Spring Security를 적용한 Jwt 기반 로그인 프로젝트 - 0 프로젝트 시작 전 가볍게 스프링 시큐리티와 JWT 로그인 방식을 알아보고 시작하겠습니다.  🔒 Spring Security Framework  Spring Security는 Spring 기반의 Application의 보안을 담당하는 Framework 이다. 인증(Authentication)과 인가(Authorization)에 대한 처리를 Filter 기반으로 처리를 해주며 많은 Filter가 제공되어 많은 보안 관련 옵션들을 개발자가 하나씩 작성하지 않고 쉽게 처리할 수 있는 장점이 있습니다.  Authentication & Authorization  1️⃣ Authentication - 인증 접속하려는 사용자가 본인인지 확인하는 인증 절차 2️⃣ Authorization - 인가 / 권한 인증된 사용자가 요청한 자원에…","fields":{"slug":"/securityjwtlogin-0/"},"frontmatter":{"categories":"Spring-Security Spring-Boot Jwt Login TIL","title":"SecurityJwtLogin - 0 [개요 - Spring Security Framework]","date":"December 01, 2022"}},"next":{"fields":{"slug":"/KakaoBlind-2022-파괴되지않은건물/"}},"previous":{"fields":{"slug":"/securityjwtlogin-1/"}}},{"node":{"id":"b6b1f7a0-2111-504c-9a0b-24ef832f39a5","excerpt":"보안의 3요소 CIA와 RSA  해당 내용은 메타코딩 - 스프링부트 시큐리티 강의를 들으며 정리한 내용입니다. TCP 통신이 갖고 있는 보안상의 문제점에 대해 살펴보고 RSA 인증 방법을 살펴본다. Web은 TCP 프로토콜을 이용하기 때문에 어떠한 보안상의 문제가 있고, 이를 해결하기 위해 어떤 방식을 사용할 수 있는지는 중요한 내용이다.  보안의 3요소 - CIA 💥 Confidentiality - 기밀성  \nC를 해커라 했을 때, 해커가 중간에 데이터를 가로챌 수 있다. - 기밀성이 깨진다. 💥 Integrity & Available - 무결성 & 가용성  \nC가 가로채 위조 데이터를 전송하게 되면 데이터의 무결성이 꺠지고, B는 제대로 된 데이터를 받지 못해 가용성이 깨진다.  1️⃣ : Key를 뺏기면 기밀성 위배 2️⃣ : Key를 뺏기면 무결성 위배 3️⃣ : 수신자가 Key가 없다면 가용성 위배 ⚒ Key를 수신자가 가지고 있어야 하기 때문에, 열쇠 전달의 문제도 발생한다. 🔥 …","fields":{"slug":"/cia-rsa/"},"frontmatter":{"categories":"Network TCP CIA RSA TIL","title":"TCP 통신의 보안 - TCP, CIA, RSA","date":"May 12, 2022"}},"next":{"fields":{"slug":"/jwt-structure/"}},"previous":{"fields":{"slug":"/swea-4699-콩순이의 가장 싼 팰린드롬/"}}},{"node":{"id":"f4488efe-1b19-5d76-a197-1371b6d80d0f","excerpt":"JWT - Json Web Token  해당 내용은 메타코딩 - 스프링부트 시큐리티 강의를 들으며 정리한 내용입니다. JWT는 Json Web Token으로 Web에서 Json 객체로 정보를 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다. ⚒ 여기에서 RFC란 여러 내부망들이 서로 연결할 때, 서로 약속된 규칙으라고 생각하면 된다.  JWT는 언제 사용할까?  JWT 구조 xxxxx.yyyyy.zzzzz xxxxx : Header yyyyy : Payload zzzzz : Signature 💥 Header : 토큰 유형, 서명 알고리즘  💥 Payload : 엔티티(사용자) 및 추가 데이터에 대한 설명  💥 Payload : 엔티티(사용자) 및 추가 데이터에 대한 설명  Header, Payload, Signature 를 종합해 보면 다음과 같다. header부분은 header에 해당하는 값이 인코딩 된 값이고, Payload는 Payload에 해당하는 값이 인코딩 된 …","fields":{"slug":"/jwt-structure/"},"frontmatter":{"categories":"JWT Login TIL","title":"JWT 구조 - JWT Structure & 장점","date":"May 12, 2022"}},"next":{"fields":{"slug":"/osi7Layer/"}},"previous":{"fields":{"slug":"/cia-rsa/"}}},{"node":{"id":"7882d6b1-642f-541b-aca0-83a6d053680c","excerpt":"Open Systems Interconnection 7 Layer  OSI 7계층이란? 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 개방형 시스템 상호 연결 모델의 표준이다.  OSI 7계층 분리 이유 모든 시스템들의 상호 연결에 있어 문제 없도록 표준을 정함. 계층을 나눠 통신이 일어나는 과정을 단계별로 확인할 수 있음. 장점 : 7계층 중 특정 Layer에 이상이 생기면 다른 장비 및 SW는 유지하고 해당 Layer 장비만 교체하면 된다.  OSI 7계층 구조    응용 프로그램에서 다른 응용 프로그램으로의 통신을 위해 빨간색 화살표를 따라 통신이 이루어진다. 송신자의 관점으로 설명을 진행한다.  💥 7계층 : Application Layer - 응용 계층 응용 프로세서 간의 정보 교환을 담당한다. \n여기에서 중요한 점은 응용 계층은 응용 프로그램이 아니다. HTTP와 같은 프로토콜이 여기에 해당한다. \n⚒ 대표적으로 HTTP (HyperText Transfer Proto…","fields":{"slug":"/osi7Layer/"},"frontmatter":{"categories":"Network OSI-7계층 TIL","title":"OSI 7계층 - 통신 Open Systems Interconnection 7 Layer","date":"May 12, 2022"}},"next":{"fields":{"slug":"/tcp-udp/"}},"previous":{"fields":{"slug":"/jwt-structure/"}}},{"node":{"id":"acbef66e-b5ed-5058-8f8c-608e15079263","excerpt":"TCP VS UDP  💥 TCP - Transmission Control Protocol 우선 간단한 그림을 통해 TCP의 데이터 송신 과정을 살펴보자.\n   ✔ ACK(확인 신호)를 응답받아야 다음 메세지를 전송하고 응답을 받지 못하면 재전송을 한다. 이러한 특징때문에 신뢰성 이 높지만 속도가 비교적 느리다. TCP 특징 1️⃣ : 연결형 서비스 3-Way Handshaking 과정을 통해 연결한다. 4-Way Handshaking 과정을 통해 연결을 해제한다. 3-Way Handshaking   1️⃣ : Client가 서버에 접속을 요청하는 SYN 패킷을 전송한다. \n2️⃣ : 서버는 Client에게 SYN 요청을 받고 Client에게 요청을 수락하는 ACK 와 SYN flag가 설정된 패킷을 전송한다. Client가 다시 ACK을 응답하기를 기다린다. \n3️⃣ : Client는 서버에게 ACK 응답을 전송하고 연결이 서로 이루어진다. 이후 데이터가 오고 간다.\n 4-Way Handshak…","fields":{"slug":"/tcp-udp/"},"frontmatter":{"categories":"Network TCP UDP TIL","title":"TCP/UDP 통신 [통신 - TCP/UDP]","date":"May 12, 2022"}},"next":{"fields":{"slug":"/session-login/"}},"previous":{"fields":{"slug":"/osi7Layer/"}}},{"node":{"id":"9cf89c1a-d082-5d6d-aeea-11ba4ba4a07c","excerpt":"Session Login  해당 내용은 메타코딩 - 스프링부트 시큐리티 강의를 들으며 정리한 내용입니다.\n JWT(Json Web Token)을 살펴보기 전에 왜 JWT를 쓰고 어디에 사용되는지 확인하기 위해 먼저 Session Login을 알아보고 어떤 문제점들이 있는지 확인해보자. 우선 서버 Session은 Client가 최초 접근시 서버의 Session ID 목록을 관리하는 곳에 자동으로 해당 브라우저에 대한 세션 ID를 생성해 관리하게 된다. 생성된 Session ID를 html 반환시 헤더(쿠키)에 담아 전달하고 이후 두 번째 접근부터는 이 세션 ID가 포함된 요청이 서버로 들어오게 된다. 💥 Session을 왜 사용할까? 이러한 특징을 Stateful 이라고 한다.  Session 기반 Login 세션 기반 로그인을 그림을 통해 확인해 본다.  \n 3️⃣-4️⃣ : 생성된 세션 ID를 쿠키에 담아 클라이언트에게 전달하고 클라이언트는 이 세션 ID를 저장해둔다.  5️⃣-7️⃣ : Lo…","fields":{"slug":"/session-login/"},"frontmatter":{"categories":"JWT Session Login TIL","title":"Session Login - JWT 로그인에 앞선 Session Login","date":"May 11, 2022"}},"next":{"fields":{"slug":"/swea-10805-야바위/"}},"previous":{"fields":{"slug":"/tcp-udp/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}